package frc.robot.MPU6050;

import static frc.robot.MPU6050.MPU6050Constants.AutoGenerated.*;

import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.Timer;


public class MPU6050New extends MPU6050Base{
    // private int dmpPacketSize = 28;
    
    /**
     * Creates a new MPU6050 on the specified port.
     * @param port The port to use.
     */
    public MPU6050New(I2C.Port port) {
        super(port);
    }

    @Override
    public void initialize() {
        setClockSource(MPU6050_CLOCK_PLL_XGYRO);
        setFullScaleGyroRange(MPU6050_GYRO_FS_250);
        setFullScaleAccelRange(MPU6050_ACCEL_FS_2);
        setSleepEnabled(false);
    }

    public short getRawRateX() {
        return mpu6050.readShort(MPU6050_RA_GYRO_XOUT_H);
    }

    public short getRawRateY() {
        return mpu6050.readShort(MPU6050_RA_GYRO_YOUT_H);
    }

    public short getRawRateZ() {
        return mpu6050.readShort(MPU6050_RA_GYRO_ZOUT_H);
    }

    public short getRawAccelX() {
        return mpu6050.readShort(MPU6050_RA_ACCEL_XOUT_H);
    }

    public short getRawAccelY() {
        return mpu6050.readShort(MPU6050_RA_ACCEL_YOUT_H);
    }

    public short getRawAccelZ() {
        return mpu6050.readShort(MPU6050_RA_ACCEL_ZOUT_H);
    }

    /* FIFO AND DMP STUFF */
    public boolean resetFIFO() {
        return mpu6050.write(MPU6050_RA_USER_CTRL, 0b00000100); // bit 2 is FIFO reset
    }

    public boolean resetDMP() {
        return mpu6050.write(MPU6050_RA_USER_CTRL, 0b00001000); // bit 3 is DMP reset
    }
 
    public int getFIFOCount() {
        return mpu6050.readShort(MPU6050_RA_FIFO_COUNTH);
    }
    
    public byte[] getFIFOBytes(int length) {
        return mpu6050.readBytes(MPU6050_RA_FIFO_R_W, length);
    }

    /**
     * Gets the current FIFO packet.
     * will wait until the FIFO has the required amount of bytes. unless it takes more than 0.2 seconds.
     * in that case it will return the FifoPacket.
     * @param length
     * @return the current FIFO packet. null if failed (aborted or timed out)
     */
    protected byte[] getCurrentFIFOPacket(int length) {
        int fifoC = -1;
        double breakTime = Timer.getFPGATimestamp();
        boolean packetReceived = false;
        final int TRASHBufferSize = 32;
        do {
            if ((fifoC = getFIFOCount())  > length) {
   
                if (fifoC > 200) { // if you waited to get the FIFO buffer to > 200 bytes it will take longer to get the last packet in the FIFO Buffer than it will take to reset the buffer and wait for the next to arrive
                    resetFIFO(); // Fixes any overflow corruption
                    fifoC = 0;
                    while ((fifoC = getFIFOCount()) !=0 && ((Timer.getFPGATimestamp() - breakTime) <= 0.15)); // Get Next New Packet
               } else { //We have more than 1 packet but less than 200 bytes of data in the FIFO Buffer
                    while ((fifoC = getFIFOCount()) > length) {  // Test each time just in case the MPU is writing to the FIFO Buffer
                        fifoC = fifoC - length; // Save the last packet
                        int RemoveBytes;
                        while (fifoC > 0) { // fifo count will reach zero so this is safe
                            RemoveBytes = (fifoC < TRASHBufferSize) ? fifoC : TRASHBufferSize; // Buffer Length is different than the packet length this will efficiently clear the buffer
                            getFIFOBytes(RemoveBytes);
                            fifoC -= RemoveBytes;
                        }
                    }
                }
            }
            if (fifoC == -1) return null; // Called too early no data or we timed out after FIFO Reset
            // We have 1 packet
            packetReceived = fifoC == length;
            if (!packetReceived && (Timer.getFPGATimestamp() - breakTime) > (0.15)) return null; // We have waited too long for the packet to arrive
        } while (!packetReceived);
        return getFIFOBytes(length); //Get 1 packet
    }

    /* FIFO AND DMP STUFF OVER */


    public void PID(int readAddress, float kP, float kI, int loops) {
        int saveAddress = (readAddress == 0x3B)? 0x06:0x13;

        int data;
        float reading;
        int[] bitZero = new int[3];
        int shift = 2;
        float[] ITerm = new float[3];
        float error, PTerm;
        int eSample;
        long eSum;
        int gravity = 8192;
        if (readAddress == 0x3B) {
            gravity = 16384 >> getFullScaleAccelRange();
        }
        
        for (int i = 0; i < 3; i++) {
            data = mpu6050.readShort(saveAddress + (i * 2));
            reading = data;
            if (saveAddress != 0x13) {
                bitZero[i] = data;
                ITerm[i] = ((float)reading) * 8;
            } else {
                ITerm[i] = reading * 4;
            }

        }
    
        for (int L = 0; L < loops; L++) {
            eSample = 0;
            for (int c = 0; c < 100; c++) {// 100 PI Calculations
                eSum = 0;
                for (int i = 0; i < 3; i++) {
                    data = mpu6050.readShort(readAddress + (i * 2)); // reads 1 or more 16 bit integers (Word)
                    reading = data;
                    if ((readAddress == 0x3B)&&(i == 2)) reading -= gravity;	//remove Gravity
                    error = -reading;
                    eSum += Math.abs(reading);
                    PTerm = kP * error;
                    ITerm[i] += (error * 0.001) * kI;				// Integral term 1000 Calculations a second = 0.001
                    if(saveAddress != 0x13){
                        data = Math.round((PTerm + ITerm[i] ) / 8);		//Compute PID Output
                        data = ((data)&0xFFFE) | bitZero[i];			// Insert Bit0 Saved at beginning
                    } else data = Math.round((PTerm + ITerm[i] ) / 4);	//Compute PID Output
                    mpu6050.writeWord(saveAddress + (i * shift), data);
                }
                if((c == 99) && eSum > 1000){						// Error is still to great to continue 
				c = 0;
                System.out.print("*");
			}
			if((eSum * ((readAddress == 0x3B)?.05: 1)) < 5) eSample++;	// Successfully found offsets prepare to  advance
			if((eSum < 100) && (c > 10) && (eSample >= 10)) break;		// Advance to next Loop
            }
            System.out.print('.');
		    kP *= .75;
		    kI *= .75;
		    for (int i = 0; i < 3; i++){
		    	if(saveAddress != 0x13) {
		    		data = Math.round((ITerm[i] ) / 8);		//Compute PID Output
		    		data = ((data)&0xFFFE) | bitZero[i];	// Insert Bit0 Saved at beginning
		    	} else data = Math.round((ITerm[i]) / 4);
		    	mpu6050.writeWord(saveAddress + (i * shift), data);
		    }
        }
        resetFIFO();
        resetDMP();
    }
    
    public void calibrateGyro(int loops) {
        float kP = 0.3f;
        float kI = 90;
        double x;
        x = (100 - map(loops, 1, 5, 20, 0)) * .01;
        kP *= x;
        kI *= x;
        
        PID( 0x43,  kP, kI,  loops);
    }

    public void calibrateAccel(int loops) {
        float kP = (float) 0.3;
        float kI = 20;
        double x;
        x = (100 - map(loops, 1, 5, 20, 0)) * .01;
        kP *= x;
        kI *= x;
        PID( 0x3B, kP, kI,  loops);
    }
    

    /**
     * Sets the clock source for the MPU6050.
     * @param source The clock source to set.
     * <pre> 0 = Internal 8MHz oscillator
     * 1 = PLL with X Gyro reference
     * 2 = PLL with Y Gyro reference
     * 3 = PLL with Z Gyro reference
     * 4 = PLL with external 32.768kHz reference
     * 5 = PLL with external 19.2MHz reference
     * 6 = Reserved
     * 7 = Stops the clock and keeps the timing generator in reset </pre>
     * @see MPU6050Constants.AutoGenerated#MPU6050_RA_PWR_MGMT_1
     * @return Transfer Aborted... false for success, true for aborted.
     */
    public boolean setClockSource(int source) {
        return mpu6050.write(MPU6050_RA_PWR_MGMT_1, source);
    }

    public int getFullScaleGyroRange() {
        return mpu6050.readBytes(MPU6050_RA_GYRO_CONFIG, 1)[0] & 0b00011000;
    }

    /**
     * Sets the full scale range for the Gyro.
     * @param range
     * @return
     */
    public boolean setFullScaleGyroRange(int range) {
        return mpu6050.write(MPU6050_RA_GYRO_CONFIG, range);
    }

    public int getFullScaleAccelRange() {
        return mpu6050.readBytes(MPU6050_RA_ACCEL_CONFIG, 1)[0] & 0b00011000;
    }

    /**
     * Sets the full scale range for the accelerometer.
     * @param range The range to set.
     * <pre> 
     * 0 = +/- 2g
     * 1 = +/- 4g
     * 2 = +/- 8g
     * 3 = +/- 16g 
     * </pre>
     * @return Transfer Aborted... false for success, true for aborted.
     */
    public boolean setFullScaleAccelRange(int range) {
        return mpu6050.write(MPU6050_RA_ACCEL_CONFIG, range);
    }

    public boolean setSleepEnabled(boolean enabled) {
        return mpu6050.write(MPU6050_RA_PWR_MGMT_1, enabled ? 0x40 : 0x00);
    }

    public short[] getActiveOffsets() {
        short[] offsets = new short[6];
        offsets = mpu6050.readWords(MPU6050_RA_XA_OFFS_H, 3);
        short[] gyroOffsets = mpu6050.readWords(0x13, 3); // size of 3
        System.arraycopy(gyroOffsets, 0, offsets, 3, 6);
        return offsets;
    }

    public void printActiveOffsets() {
        short[] offsets = getActiveOffsets();
        System.out.println(offsets);
    }
}
