package frc.robot.MPU6050;

import static frc.robot.MPU6050.MPU6050Constants.AutoGenerated.*;

import java.util.Arrays;


import static frc.robot.MPU6050.DMPFirmwareConstant.I2CDEVDMPFIRMWARE;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.interfaces.Gyro;

public class AxisMotionApps extends MPU6050New implements Gyro{
    public boolean dmpReady;
    private boolean dmpInit;
    private final int dmpPacketSize = 28;

    @Override
    public void close() throws Exception {
        mpu6050.close();
    }

    public AxisMotionApps(I2C.Port port) {
        this(port, 5);
    }

    public AxisMotionApps(I2C.Port port, int attemptAmount) {
        super(port);
        dmpReady = false;
        dmpInit = false;
        for (int i = 0; i < attemptAmount; i++) {
            System.out.println("DMP Attempt " + i);
            if(dmpInitialize() && !dmpInit) {
                DriverStation.reportError("DMP Init Failed!", false);
                continue;
            }
            dmpInit = true;
            calibrateAccel(6);
            calibrateGyro(6);
            if (setDMPEnabled(true)) {
                DriverStation.reportError("DMP Enable Failed!", false);
                continue;
            };
            dmpReady = true;
            break;
        }
    }

    /**
     * Initializes the DMP.
     * @return Transfer Aborted... false for success, true for aborted.
     */
    public boolean dmpInitialize() { // I am too annoyed to make all these functions, so I am just going to put them all here.
        mpu6050.write(MPU6050_RA_PWR_MGMT_1, 0x80); // Reset Device
        Timer.delay(0.1);
        mpu6050.write(MPU6050_RA_SIGNAL_PATH_RESET, 0b00001100); // Reset all sensors
        Timer.delay(0.1);
        
        setClockSource(MPU6050_CLOCK_PLL_XGYRO); // Set clock source to gyro
        mpu6050.write(MPU6050_RA_INT_ENABLE, 0x00); // Disable all interrupts 
        mpu6050.write(MPU6050_RA_FIFO_EN, 0x00); // Disable FIFO, We will be using the DMP's FIFO
        setFullScaleAccelRange(MPU6050_ACCEL_FS_2); // Set the accelerometer to +/- 2g
        mpu6050.write(MPU6050_RA_SMPLRT_DIV, 0x04); // Set the sample rate to 200Hz
        mpu6050.write(MPU6050_RA_CONFIG, 0x01); // Digital Low Pass Filter (DLPF) Configuration 188HZ
        
        if(writeProgMemoryBlock(I2CDEVDMPFIRMWARE, I2CDEVDMPFIRMWARE.length, 0, 0, true)) return true; // Load DMP Firmware
        
        mpu6050.writeWord(MPU6050_RA_DMP_CFG_1, 0x0400); // DMP Program Start Address
        setFullScaleGyroRange(MPU6050_GYRO_FS_2000); // Set the gyro to +/- 2000 degrees per second (idk why, but it is what the I2C DEV code does)
        mpu6050.write(MPU6050_RA_USER_CTRL, 0xC0); // Enable Fifo and Reset Fifo
        mpu6050.write(MPU6050_RA_INT_ENABLE, 0x02); // RAW_DMP_INT_EN on
        
        return false;
    }

    /**
     * Load and verify DMP image.
     * @param length Length of DMP image.
     * @param firmware DMP code.
     * @param start_addr Starting address of DMP code memory.
     * @return Transfer Aborted... false for success, true for aborted.
    */
    private boolean loadDMPFirmware(short length, char firmware[], short start_addr) {
        if (dmpReady) return false;
        short ii;
        short this_write;
        // Must divide evenly into bank_size to avoid bank crossings.
        final int LOAD_CHUNK = 16;
        byte[] cur = new byte[LOAD_CHUNK];
        byte[] tmp = new byte[2];

        if (firmware == null) return true;

        for (ii = 0; ii < length; ii += this_write) {
            this_write = (short) Math.min(LOAD_CHUNK, length - ii);
            if (writeMem(ii, this_write, Arrays.copyOfRange(firmware, ii, ii + this_write))) return true;

            cur = readMem(ii, this_write); if (cur == null) return true;

            byte[] tmp2 = new byte[this_write];
            
            for (int i = 0; i < this_write; i++) {
                tmp2[i] = (byte) firmware[ii + i];
            }

            if (Arrays.equals(cur, tmp2)) {
                System.out.println("Passed! " + ii);
            } else {
                DriverStation.reportError("Failed! " + ii,false);
                System.out.println("Failed! " + ii);
                return true;
            }
        }
        
        tmp[0] = (byte) (start_addr >> 8);
        tmp[1] = (byte) (start_addr & 0xFF);
        if (mpu6050.write(MPU6050_RA_DMP_CFG_1, tmp[0])) return true;

        dmpReady = true;
        return false;
    }
    
    public boolean setDMPEnabled(boolean enable) {
        if (enable) {
            return mpu6050.write(MPU6050_RA_USER_CTRL, 0x80); // Enable DMP
        }
        else {
            return mpu6050.write(MPU6050_RA_USER_CTRL, 0x00); // Disable DMP
        }
    }

    public byte[] getCurrentFIFOPacket() {
        byte[] data = super.getCurrentFIFOPacket(dmpPacketSize);
        return data;
    }
    
    public int[] dmpGetQuaternion(byte[] FIFOPacket) {
        int[] data = new int[4];
        data[0] = ((FIFOPacket[0] << 8) | FIFOPacket[1]);
        data[1] = ((FIFOPacket[4] << 8) | FIFOPacket[5]);
        data[2] = ((FIFOPacket[8] << 8) | FIFOPacket[9]);
        data[3] = ((FIFOPacket[12] << 8) | FIFOPacket[13]);
        return data;
    }

    /* GYRO IMPLEMENT */
    @Override
    public void calibrate() {
        calibrateGyro(1);
    }

    @Override
    public void reset() {
        throw new RuntimeException("Resetting not implemented yet");
        //TODO: Set OFFSET function. (maybe use DMP? or create offset variables?)
    }

    @Override
    public double getAngle() {
        //TODO: Get Angle(Trough DMP)
        throw new RuntimeException("Get Angle is not implemented yet");
    }

    @Override
    public double getRate() {
        //TODO: Use Calibrated Gyro (Trough DMP)
        return getRawRateZ();
    }
}
